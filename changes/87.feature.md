SpeQtrum jobs now retain their concrete result types from submission through retrieval, so every handle produced by `submit` returns the right `FunctionalResult` whether you are sampling, evolving in time, or orchestrating a variational loop. Waiting for a fresh job still takes a single call, but the typed detail that comes back no longer needs manual casting:

```python
job_handle = speqtrum.submit(Sampling(circuit), device="cuda_state_vector")
job = speqtrum.wait_for_job(job_handle)
results = job.get_results()  # Your IDE will know this is a SamplingResult
```

The same strong typing applies when inspecting historical runs. Recreate a handle with the appropriate class method, pass it to `get_job`, and the returned `TypedJobDetail` exposes the precise payload you expect:

```python
job_handle = JobHandle.sampling(1200853)
job = speqtrum.get_job(job_handle)
results = job.get_results()  # Your IDE will know this is a SamplingResult
```
