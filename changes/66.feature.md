Ansatz now **inherits** from `Circuit`.

We refactored the variational template hierarchy so that `Ansatz` is an abstract subclass of `Circuit` rather than a separate builder/factory. Concrete templates like `HardwareEfficientAnsatz` are therefore circuits themselves. This simplifies downstream code: anything that accepted a `Circuit` now accepts an ansatz instance directly, without an extra “build” or “get\_circuit” step. As part of this change, the circuit is constructed during initialization, configurable attributes were made private with read-only properties (`layers`, `connectivity`, `structure`, `one_qubit_gate`, `two_qubit_gate`), and parameter handling became deterministic: when `initial_parameters` is omitted, all single-qubit parameters default to `0.0`; when provided, the length must match the spefic ansatz implementation. For HardwareEfficientAnsatz number of parameters must equal to `(layers + 1) * nqubits * len(one_qubit_gate.PARAMETER_NAMES)`. The `structure` flag is now meaningful at build time: `grouped` schedules `U(all) → E(all)` per layer, while `interposed` applies `U(q) → E(all)` for each qubit within a layer. Measurement gates are no longer appended automatically; add them explicitly if needed. The `nparameters` computation remains available via the parent `Circuit`.

**Example**

```python
from qilisdk.digital.ansatz import HardwareEfficientAnsatz, U3, CNOT

nqubits = 4
layers = 2
params = [0.1] * (nqubits * (layers + 1) * len(U3.PARAMETER_NAMES))

ansatz = HardwareEfficientAnsatz(
    nqubits=4,
    layers=2,
    connectivity="linear",
    structure="grouped",                 # or "interposed"
    one_qubit_gate=U3,
    two_qubit_gate=CNOT,
    initial_parameters=params,           # omit for all-zeros
)
ansatz.draw()                     # ansatz is a Circuit

# add measurements explicitly if your workflow requires them
```
