Adding Observable cost function that now could be used with VariationalPrograms. 

You can construct an Observable cost function by using ``Hamiltonian``, ``PauliOperators``, or ``QuantumObjects``.

The cost is the expected value of the observable given the final state after the simulation. 


```python
from qilisdk.analog import Z, PauliZ
from qilisdk.common import QuantumObject
from qilisdk.cost_functions import ObservableCostFunction
import numpy as np


h = Z(0) + 2 * Z(1)
cost_function = ObservableCostFunction(h)

## or

cost_function = ObservableCostFunction(PauliZ(0))

## or

cost_function = ObservableCostFunction(QuantumObject(np.array([[1, 0], [0, -1]])))
```

Usage: 
```python
from qilisdk.analog import Z
from qilisdk.common import ket, tensor_prod
from qilisdk.cost_functions import ObservableCostFunction
from qilisdk.functionals import TimeEvolutionResult

n = 2

H = sum(Z(i) for i in range(n))

ocf = ObservableCostFunction(H)

te_results = TimeEvolutionResult(
    final_expected_values=np.array([[-0.9, 0]]),
    expected_values=None,
    final_state=tensor_prod([ket(1), ket(1)]),
    intermediate_states=None,
)
cost = ocf.compute_cost(te_results)
# Output: -2
```