Rebuilt analog scheduling around a single, flexible `Schedule`/`Interpolator`: `LinearSchedule` is removed, coefficients can be defined as callables or time intervals with step/linear interpolation, max-time rescaling, shared parameter tracking, and updated visualization/backends.

Centralized parameter management in `Parameterizable` so Hamiltonians, circuits, schedules, and gates all inherit consistent parameter getters/setters, constraint checking, and validation; variables add comparison helpers, caching, and math maps.

Constraint-aware execution now threads through sampling, time evolution, variational programs, and optimizer loops, rejecting parameter sets that violate declared constraints; tests and serialization use the new APIs.

Examples:
```python
from qilisdk.analog import Schedule, X, Z
from qilisdk.analog.schedule import Interpolation
from qilisdk.core import Parameter

T = 10.0
schedule = Schedule(
    hamiltonians={"driver": X(0), "problem": Z(0)},
    coefficients={
        # Interval syntax expands to sampled points; callables can reference time directly.
        "driver": {(0, T): lambda t: 1 - t / T},
        "problem": {(0, T): lambda t: t / T},
    },
    dt=0.5,
    interpolation=Interpolation.LINEAR,
)
schedule.set_max_time(Parameter("T_max", 8.0))
schedule.draw()
```

```python
from qilisdk.core import GreaterThanOrEqual, Parameter
from qilisdk.functionals import Sampling, VariationalProgram

# Constrain theta >= phi for a variational run; violations short-circuit the optimizer step.
theta = Parameter("theta", 0.4, bounds=(0, 1))
phi = Parameter("phi", 0.3, bounds=(0, 1))
constraints = [GreaterThanOrEqual(theta, phi)]

vp = VariationalProgram(
    functional=Sampling(...),
    optimizer=...,
    cost_function=...,
    parameter_constraints=constraints,
)
```
