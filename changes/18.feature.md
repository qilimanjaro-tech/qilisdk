This PR adds foundational support for Variables, Terms, Constraints, Models, and QUBO processing, along with corresponding unit tests and exception definitions.

- Variables: 
    
    - in the variables module we provide classes and functions to define Spin, Binary, and Generic Variables. 
    ```python
    b = BinaryVariable("b")
    s = SpinVariable("s")
    v = Variable("v", domain=Domain.REAL, bounds=(-2, 2), encoding=BitWise, precision=1e-3)
    ```
    - We define three different ways to encode continuous variables into binary encoding:
        - **Bitwise**: encodes the continuous variable's domain into a bit wise binary string. 
            ```python
            v = Variable("v", domain=Domain.POSITIVE_INTEGER, bounds=(0, 7), encoding=Bitwise)
            v.to_binary()

            >>> v(0) + (2) * v(1) + (4) * v(2) 
            ```
        - **OneHot**: encodes the continuous variable's domain using one-hot encoding.
            ```python
            v = Variable("v", domain=Domain.POSITIVE_INTEGER, bounds=(0, 7), encoding=OneHot)
            v.to_binary()

            >>> v(1) + (2) * v(2) + (3) * v(3) + (4) * v(4) + (5) * v(5) + (6) * v(6) + (7) * v(7) 
            ```
            Note: `v(0)` doesn't appear in the expression because it has the coefficient `0`.
        - **DomainWall**: encodes the continuous variable's domain using domain wall encoding.
            ```python
            v = Variable("v", domain=Domain.POSITIVE_INTEGER, bounds=(0, 7), encoding=DomainWall)
            v.to_binary()

            >>> v(0) + v(1) + v(2) + v(3) + v(4) + v(5) + v(6)
            ```
    - using these variables we added the ability to construct:
        - Mathematical expressions:
         ```python
            x = Variable("x", domain=Domain.POSITIVE_INTEGER, bounds=(0, 7), encoding=Bitwise)
            y = Variable("y", domain=Domain.POSITIVE_INTEGER, bounds=(2, 10), encoding=Bitwise)
            term = 3 * x + 4 * y + x ** 2 + 5 * x * y
            print(term)

            >>> (3) * x + (4) * y + (x^2) + (5) * (x * y) 
        ```
        - Comparison terms: 
        ```python
            x = Variable("x", domain=Domain.POSITIVE_INTEGER, bounds=(0, 7), encoding=Bitwise)
            y = Variable("y", domain=Domain.POSITIVE_INTEGER, bounds=(2, 10), encoding=Bitwise)

            term1 = 3 * x + 4 * y 
            term2 = x**2 + 3
            comparison = EQ(term1, term2)
            print(comparison)

            >>> (3) * x + (4) * y + (-1.0) * (x^2)  == (3.0)             
        ```
        comparison terms can be: 
        | Comparison Term              | Code Representation     | Short-form Representation     |
        | :--------------------------- | :---------------------: | ----------------------------: |
        | Equal to                     |  ``Equal``              | ``EQ``                        |
        | Not Equal to                 |  ``NotEqual``           | ``NEQ``                       |
        | Greater than                 |  ``GreaterThan``        | ``GT``                        |
        | Greater than or equal to     |  ``GreaterThanOrEqual`` | ``GEQ``                       |
        | Less than                    |  ``LessThan``           | ``LT``                        |
        | Less than or equal to        |  ``LessThanOrEqual``    | ``LEQ``                       |

        Note: both the short-form and long-form representations are valid to use in the code. 

- Models: 
    - This module provides tools to construct mathematical models and QUBO models. 
    
    Example of Constructing a model: 
    ```python
    from qilisdk.common.variables import BinaryVariable, LEQ
    from qilisdk.common.model import Model

    num_items = 4
    values = [1, 3, 5, 2]
    weights = [3, 2, 4, 5]
    max_weight = 6
    bin_vars = [BinaryVariable(f"b{i}") for i in range(num_items)]

    model = Model("Knapsack")

    objective = sum(values[i] * bin_vars[i] for i in range(num_items))
    model.set_objective(objective)

    constraint = LEQ(sum(weights[i] * bin_vars[i] for i in range(num_items)), max_weight)
    model.add_constraint("maximum weight", constraint)

    print(model)

    >>> Model name: Knapsack 
    >>> objective (obj): 
    >>>     minimize : 
    >>>     b0 + (3) * b1 + (5) * b2 + (2) * b3  
    >>> 
    >>> subject to the constraint/s: 
    >>>     maximum weight: (3) * b0 + (2) * b1 + (4) * b2 + (5) * b3  <= (6.0)  
    ```

    - QUBO (Quadratic Unconstrained Binary Optimization) models can be constructed from models directly:
    ```python
    qubo_model = model.to_qubo()
    print(qubo_model)

    Model name: QUBO_Knapsack 
    >>> objective (obj): 
    >>> 	 minimize : 
    >>> 	 b0 + (3) * b1 + (5) * b2 + (2) * b3  

    >>> subject to the constraint/s: 
    >>> 	 maximum weight: (-27.0) * b0 + (12.0) * (b0 * b1) + (24.0) * (b0 * b2) + (30.0) * (b0 * b3) + (6.0) * (b0 * maximum weight_slack(0)) + (12.0) * (b0 * maximum weight_slack(1)) + (18.0) * (b0 * maximum weight_slack(2)) + (-20.0) * b1 + (16.0) * (b1 * b2) + (20.0) * (b1 * b3) + (4.0) * (b1 * maximum weight_slack(0)) + (8.0) * (b1 * maximum weight_slack(1)) + (12.0) * (b1 * maximum weight_slack(2)) + (-32.0) * b2 + (40.0) * (b2 * b3) + (8.0) * (b2 * maximum weight_slack(0)) + (16.0) * (b2 * maximum weight_slack(1)) + (24.0) * (b2 * maximum weight_slack(2)) + (-35.0) * b3 + (10.0) * (b3 * maximum weight_slack(0)) + (20.0) * (b3 * maximum weight_slack(1)) + (30.0) * (b3 * maximum weight_slack(2)) + (-11.0) * maximum weight_slack(0) + (-20.0) * maximum weight_slack(1) + (-27.0) * maximum weight_slack(2) + (4.0) * (maximum weight_slack(0) * maximum weight_slack(1)) + (6.0) * (maximum weight_slack(0) * maximum weight_slack(2)) + (12.0) * (maximum weight_slack(1) * maximum weight_slack(2))  == (-36.0)  
    >>> 
    >>> With Lagrange Multiplier/s: 
    >>> 	 maximum weight : 100 
    ```

    Note: QUBO models can be directly translated into Ising Hamiltonians: 
    ```python
    qubo_model.to_ham()
    >>> 3305.5 - 1200.5 Z(0) - 801.5 Z(1) - 1602.5 Z(2) - 2001 Z(3) + 300 Z(0) Z(1) + 600 Z(0) Z(2) + 750 Z(0) Z(3) - 400 Z(4) + 150 Z(0) Z(4) - 800 Z(5) + 300 Z(0) Z(5) - 1200 Z(6) + 450 Z(0) Z(6) + 400 Z(1) Z(2) + 500 Z(1) Z(3) + 100 Z(1) Z(4) + 200 Z(1) Z(5) + 300 Z(1) Z(6) + 1000 Z(2) Z(3) + 200 Z(2) Z(4) + 400 Z(2) Z(5) + 600 Z(2) Z(6) + 250 Z(3) Z(4) + 500 Z(3) Z(5) + 750 Z(3) Z(6) + 100 Z(4) Z(5) + 150 Z(4) Z(6) + 300 Z(5) Z(6)
    ```
