Replacing the callable cost function with the abstract model. The Abstract Model allows the user to write an objective function that is subjected to a set of constraints. Then this is used to evaluate the cost of a given sample. 


Example: 
```python
from qilisdk.common import SciPyOptimizer
from qilisdk.common.model import QUBO, Model
from qilisdk.common.variables import LEQ, BinaryVariable
from qilisdk.digital.ansatz import HardwareEfficientAnsatz
from qilisdk.digital.digital_result import DigitalResult
from qilisdk.digital.vqe import VQE
from qilisdk.extras import CudaBackend


model = Model("Knapsack")

values = [2, 3, 7]
weights = [1, 3, 3]
max_weight = 4
b = [BinaryVariable(f"b{i}") for i in range(len(values))]

obj = sum(b[i] * values[i] for i in range(len(values)))
model.set_objective(obj, "obj")

con = LEQ(sum(b[i] * weights[i] for i in range(len(weights))), max_weight)

model.add_constraint("max_weight", con)

n_qubits = 3
ansatz = HardwareEfficientAnsatz(
    n_qubits=n_qubits, layers=2, connectivity="Linear", structure="grouped", one_qubit_gate="U2", two_qubit_gate="CNOT"
)
vqe = VQE(
    ansatz=ansatz,
    initial_params=[0 for _ in range(ansatz.nparameters)],
    model=model,
)

backend = CudaBackend()
optimizer = SciPyOptimizer(method="Powell")

result = vqe.execute(backend, optimizer, nshots=1000)
```

