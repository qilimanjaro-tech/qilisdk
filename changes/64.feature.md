# Parameterized Hamiltonians and Schedules

You can now parameterize both ``Hamiltonian`` and ``Schedule`` objects using Parameter objects. This makes it easier to define flexible, variational quantum programs.

## Parameterized Hamiltonians

You can insert symbolic parameters directly into Hamiltonian definitions, then set or update them later:

```python
from qilisdk.common import Parameter
from qilisdk.analog import Z, Y, X

p = [Parameter(f"p({i})", 2) for i in range(2)]

t = 2 * p[0]

H = 2 * Z(1) + t * Y(0) 
H2 = 3 * X(0) + p[1] * Y(0)

H3 = H + H2

print(H3) 
# Output: 2 Z(1) + 6 Y(0) + 3 X(0)

H3.set_parameters({"p(0)": 3})

print(H3) 
# Output: 2 Z(1) + 8 Y(0) + 3 X(0)

# get hamiltonian parameters
H3.get_parameters()
```

## Parameterized Schedules
You can also define schedules whose weights are parameterized functions of time.

```python
import numpy as np
from qilisdk.analog import Schedule
from qilisdk.analog.hamiltonian import X, Z
from qilisdk.common import Parameter

val = [0.3 , 0.7]
p = [Parameter(f"p({i})", val[i]) for i in range(2)]

dt = 0.1
T = 10
steps = np.linspace(0, T, int(T / dt))

# Define two Hamiltonians
h1 = X(0) + X(1) + X(2)
h2 = Z(0) - 1 * Z(1) - 2 * Z(2) + 3 * Z(0) * Z(1)

schedule = Schedule(
    T=T,
    dt=dt
)


def parameterized_schedule(t) -> float:
    if steps[t] < 2:
        return p[0] / 2 * (steps[t])
    if steps[t] < 4:
        return p[0]
    if steps[t] < 6:
        return p[0] + (p[1] - p[0]) / 2 * (steps[t] - 4)
    if steps[t] < 8:
        return p[1]
    return p[1] + (1 - p[1]) / 2 * (steps[t] - 8)


schedule.add_hamiltonian("h1", h1, lambda t: (1 - steps[t] / T))
schedule.add_hamiltonian("h2", h2, parameterized_schedule)

# set parameters
schedule.set_parameters({
    "p(0)" : 0.2,
    "p(1)" : 0.5
})

# get parameters
print(schedule.get_parameters())
```

## Mixing Hamiltonians and Schedules

You can freely combine parameterized ``Hamiltonians`` and parameterized ``Schedules``, making them ideal building blocks for Variational Programs.



```python
import numpy as np
from qilisdk.analog import Schedule
from qilisdk.analog.hamiltonian import X, Z
from qilisdk.common import Parameter

val = [0.3 , 0.7]
p = [Parameter(f"p({i})", val[i]) for i in range(2)]
h_p = [Parameter(f"h_p({i})", 0.5 * np.pi) for i in range(3)]

dt = 0.1
T = 10
steps = np.linspace(0, T, int(T / dt))

# Define two Hamiltonians
h1 = X(0) + X(1) + X(2)
h2 = sum(h_p[i] * Z(i) for i in range(3)) + 3 * Z(0) * Z(1) # parameterized hamiltonian

schedule = Schedule(
    T=T,
    dt=dt
)


def parameterized_schedule(t) -> float:
    if steps[t] < 2:
        return p[0] / 2 * (steps[t])
    if steps[t] < 4:
        return p[0]
    if steps[t] < 6:
        return p[0] + (p[1] - p[0]) / 2 * (steps[t] - 4)
    if steps[t] < 8:
        return p[1]
    return p[1] + (1 - p[1]) / 2 * (steps[t] - 8)


schedule.add_hamiltonian("h1", h1, lambda t: (1 - steps[t] / T))
schedule.add_hamiltonian("h2", h2, parameterized_schedule)

# set parameters
schedule.set_parameters({
    "p(0)" : 0.2,
    "p(1)" : 0.5
})

# get parameters
print(schedule.get_parameters())
```
## Cost Function Restructuring

Weâ€™ve refactored cost function handling into a dedicated cost function module.
- Introduced a new ``ModelCostFunction`` class that allows you to create cost functions directly from abstract models.

```python

from qilisdk.common import BinaryVariable, LEQ, Model, ObjectiveSense
from qilisdk.cost_functions import ModelCostFunction

values = [2, 3, 7]
weights = [1, 3, 3]
max_weight = 4
binary_var = [BinaryVariable(f"b{i}") for i in range(len(values))]

model = Model("Knapsack")

model.set_objective(sum(binary_var[i] * values[i] for i in range(len(values))), sense=ObjectiveSense.MAXIMIZE)

model.add_constraint("max_weights", LEQ(sum(binary_var[i] * weights[i] for i in range(len(weights))), max_weight))

model_cost_function = ModelCostFunction(model)

```

