This release introduces the new `TimeEvolution` analog algorithm along with supporting classes that empower users to simulate time-dependent quantum systems with greater flexibility and precision. The update brings a schedule-based approach that allows for dynamic interpolation between different Hamiltonians over time, making it easier to model complex evolution scenarios. New classes such as `Schedule` and `TimeEvolution` simplify the process of defining the evolution parameters, specifying initial states, and monitoring observables. For instance, the following code example demonstrates how to set up a one-qubit system with two Hamiltonians—gradually transitioning from one to the other using a linear schedule—and execute the simulation on a CUDA backend for enhanced performance:

```python
T = 10
dt = 0.1
steps = np.linspace(0, T, int(T / dt))

nqubits = 1

H1 = sum(X(i) for i in range(nqubits))
H2 = sum(Z(i) for i in range(nqubits))

schedule = Schedule(
    T,
    dt,
    hamiltonians={
        "h1": H1,
        "h2": H2
    },
    schedule={
        t: {
            "h1": 1 - steps[t] / T,
            "h2": steps[t] / T,
        }
        for t in range(len(steps))
    },
)

state = tensor([(ket(0) + ket(1)).unit() for _ in range(nqubits)]).unit()
dm = (state @ state.dag()).unit()

time_evolution = TimeEvolution(
    backend=CudaBackend(),
    schedule=schedule,
    initial_state=state,
    observables=[Z(0), X(0), Y(0), Z(nqubits - 1), X(nqubits - 1), Y(nqubits - 1)],
)

results = time_evolution.evolve(store_intermediate_results=True)
```
