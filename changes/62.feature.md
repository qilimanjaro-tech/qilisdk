Updating the structure of how variational algorithms are executed. We added a new `VariationalProgram` class that takes in a parameterized Functional, an Optimizer, and a model representing the cost function, then uses these elements to optimize the parameters of the functional. 

Moreover, due to these changes the VQE class was removed and now all variational programs will be constructed and executed using VariationalProgram. Here is an example of optimizing a VQE to solve the knapsack problem: 

```python
import numpy as np

from qilisdk.backends import QutipBackend
from qilisdk.common import BinaryVariable, LessThanOrEqual, Model, ObjectiveSense
from qilisdk.digital import CNOT, U2, HardwareEfficientAnsatz
from qilisdk.functionals import Sampling, VariationalProgram
from qilisdk.optimizers import SciPyOptimizer

values = [2, 3, 7]
weights = [1, 3, 3]
max_weight = 4
binary_var = [BinaryVariable(f"b{i}") for i in range(len(values))]

model = Model("Knapsack")

model.set_objective(sum(binary_var[i] * values[i] for i in range(len(values))), sense=ObjectiveSense.MAXIMIZE)

model.add_constraint("max_weights", LessThanOrEqual(sum(binary_var[i] * weights[i] for i in range(len(weights))), max_weight))


n_qubits = 3
ansatz = HardwareEfficientAnsatz(
    n_qubits=n_qubits, layers=3, connectivity="Linear", structure="grouped", one_qubit_gate=U2, two_qubit_gate=CNOT
)
circuit = ansatz.get_circuit([np.random.uniform(0, np.pi) for _ in range(ansatz.nparameters)])

optimizer = SciPyOptimizer(method="Powell")

backend = QutipBackend()
result = backend.execute(VariationalProgram(functional=Sampling(circuit), optimizer=optimizer, cost_model=model))

print(result)
```